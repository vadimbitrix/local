var Pinia=function(O,R){"use strict";let h;const g=t=>h=t,y=Symbol();function o(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}O.MutationType=void 0,(r=O.MutationType||(O.MutationType={})).direct="direct",r.patchObject="patch object",r.patchFunction="patch function";const P=()=>{};function A(e,n,t,r=P){e.push(n);var i=()=>{var t=e.indexOf(n);-1<t&&(e.splice(t,1),r())};return!t&&R.getCurrentScope()&&R.onScopeDispose(i),i}function M(t,...e){t.slice().forEach(t=>{t(...e)})}const w=t=>t(),k=Symbol(),T=Symbol();function x(n,t){n instanceof Map&&t instanceof Map?t.forEach((t,e)=>n.set(e,t)):n instanceof Set&&t instanceof Set&&t.forEach(n.add,n);for(const i in t){var e,r;t.hasOwnProperty(i)&&(e=t[i],r=n[i],n[i]=o(r)&&o(e)&&n.hasOwnProperty(i)&&!R.isRef(e)&&!R.isReactive(e)?x(r,e):e)}return n}const e=Symbol();function E(t){return!o(t)||!Object.prototype.hasOwnProperty.call(t,e)}const I=Object["assign"];function d(a,t,n={},c,e,r){let i;const o=I({actions:{}},n),s={deep:!0};let u,f,p,l=[],h=[];var y=c.state.value[a];let d;function v(t){let e;u=f=!1,e="function"==typeof t?(t(c.state.value[a]),{type:O.MutationType.patchFunction,storeId:a,events:p}):(x(c.state.value[a],t),{type:O.MutationType.patchObject,payload:t,storeId:a,events:p});const n=d=Symbol();R.nextTick().then(()=>{d===n&&(u=!0)}),f=!0,M(l,e,c.state.value[a])}r||y||(c.state.value[a]={}),R.ref({});var b,$=r?function(){const t=n["state"],e=t?t():{};this.$patch(t=>{I(t,e)})}:P;const _=(i,t="")=>{if(k in i)return i[T]=t,i;function o(){g(c);const t=Array.from(arguments),e=[],n=[];let r;M(h,{args:t,name:o[T],store:S,after:function(t){e.push(t)},onError:function(t){n.push(t)}});try{r=i.apply(this&&this.$id===a?this:S,t)}catch(t){throw M(n,t),t}return r instanceof Promise?r.then(t=>(M(e,t),t)).catch(t=>(M(n,t),Promise.reject(t))):(M(e,r),r)}return o[k]=!0,o[T]=t,o},j={_p:c,$id:a,$onAction:A.bind(null,h),$patch:v,$reset:$,$subscribe(e,n={}){const t=A(l,e,n.detached,()=>r()),r=i.run(()=>R.watch(()=>c.state.value[a],t=>{("sync"===n.flush?f:u)&&e({storeId:a,type:O.MutationType.direct,events:p},t)},I({},s,n)));return t},$dispose:function(){i.stop(),l=[],h=[],c._s.delete(a)}},S=R.reactive(j),m=(c._s.set(a,S),(c._a&&c._a.runWithContext||w)(()=>c._e.run(()=>(i=R.effectScope()).run(()=>t({action:_})))));for(const O in m){const g=m[O];if(R.isRef(g)&&(!R.isRef(b=g)||!b.effect)||R.isReactive(g))r||(y&&E(g)&&(R.isRef(g)?g.value=y[O]:x(g,y[O])),c.state.value[a][O]=g);else if("function"==typeof g){const R=_(g,O);m[O]=R,o.actions[O]=g}}return I(S,m),I(R.toRaw(S),m),Object.defineProperty(S,"$state",{get:()=>c.state.value[a],set:e=>{v(t=>{I(t,e)})}}),c._p.forEach(t=>{I(S,i.run(()=>t({store:S,app:c._a,pinia:c,options:o})))}),y&&r&&n.hydrate&&n.hydrate(S.$state,y),u=!0,f=!0,S}let n="Store";function t(r,i){return Array.isArray(i)?i.reduce((t,e)=>(t[e]=function(){return r(this.$pinia)[e]},t),{}):Object.keys(i).reduce((t,n)=>(t[n]=function(){const t=r(this.$pinia),e=i[n];return"function"==typeof e?e.call(this,t):t[e]},t),{})}var r=t;return O.acceptHMRUpdate=function(t,e){return()=>{}},O.createPinia=function(){const t=R.effectScope(!0),e=t.run(()=>R.ref({}));let n=[],r=[];const i=R.markRaw({install(t){g(i),(i._a=t).provide(y,i),t.config.globalProperties.$pinia=i,r.forEach(t=>n.push(t)),r=[]},use(t){return(this._a?n:r).push(t),this},_p:n,_a:null,_e:t,_s:new Map,state:e});return i},O.defineStore=function(u,f,t){let p;const l="function"==typeof f;function e(t,e){var n=R.hasInjectionContext();if((t=t||(n?R.inject(y,null):null))&&g(t),!(t=h)._s.has(u))if(l)d(u,f,p,t);else{var r=u,i=(n=p,t);const{state:o,actions:a,getters:c}=n,s=i.state.value[r];d(r,function(){s||(i.state.value[r]=o?o():{});var t=R.toRefs(i.state.value[r]);return I(t,a,Object.keys(c||{}).reduce((t,e)=>(t[e]=R.markRaw(R.computed(()=>{g(i);var t=i._s.get(r);return c[e].call(t,t)})),t),{}))},n,i,0,!0)}return t._s.get(u)}return p=l?t:f,e.$id=u,e},O.disposePinia=function(t){t._e.stop(),t._s.clear(),t._p.splice(0),t.state.value={},t._a=null},O.getActivePinia=()=>R.hasInjectionContext()&&R.inject(y)||h,O.mapActions=function(n,r){return Array.isArray(r)?r.reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[e](...t)},t),{}):Object.keys(r).reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[r[e]](...t)},t),{})},O.mapGetters=r,O.mapState=t,O.mapStores=function(...t){return t.reduce((t,e)=>(t[e.$id+n]=function(){return e(this.$pinia)},t),{})},O.mapWritableState=function(n,r){return Array.isArray(r)?r.reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[e]},set(t){return n(this.$pinia)[e]=t}},t),{}):Object.keys(r).reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[r[e]]},set(t){return n(this.$pinia)[r[e]]=t}},t),{})},O.setActivePinia=g,O.setMapStoreSuffix=function(t){n=t},O.shouldHydrate=E,O.skipHydrate=function(t){return Object.defineProperty(t,e,{})},O.storeToRefs=function(e){const t=R.toRaw(e),n={};for(const i in t){var r=t[i];r.effect?n[i]=R.computed({get:()=>e[i],set(t){e[i]=t}}):(R.isRef(r)||R.isReactive(r))&&(n[i]=R.toRef(e,i))}return n},O}({},Vue);
